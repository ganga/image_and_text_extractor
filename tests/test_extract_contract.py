import re
import httpx
import os
from pathlib import Path
from io import BytesIO
from PIL import Image

BASE_URL = os.getenv("BASE_URL", "http://api:8000")

UUID_RE = re.compile(
    r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-"
    r"[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$"
)

def _tiny_png_bytes() -> bytes:
    # Valid 1x1 PNG generated by PIL
    img = Image.new("RGB", (1, 1), color="white")
    bio = BytesIO()
    img.save(bio, format="PNG")
    return bio.getvalue()

def test_extract_rejects_non_image():
    files = {"file": ("note.txt", b"hello", "text/plain")}
    data = {"store_outputs": "true", "return_annotated": "true", "ocr_engine": "paddle"}

    r = httpx.post(f"{BASE_URL}/extract", files=files, data=data, timeout=20)

    # Contract expects 400 for non-image
    assert r.status_code == 400

def test_extract_happy_path_contract_minimum():
    img = _tiny_png_bytes()
    files = {"file": ("page.png", img, "image/png")}
    data = {"store_outputs": "false", "return_annotated": "true", "ocr_engine": "paddle"}

    r = httpx.post(f"{BASE_URL}/extract", files=files, data=data, timeout=120)

    # This will FAIL until you implement /extract (currently likely 404)
    assert r.status_code == 200

    body = r.json()

    # meta
    assert "meta" in body
    assert UUID_RE.match(body["meta"]["request_id"])

    # image meta must be >0
    assert body["meta"]["image"]["width"] >= 1
    assert body["meta"]["image"]["height"] >= 1

    # timings
    t = body["meta"]["timings_ms"]
    for k in ["preprocess", "layout", "ocr", "crop"]:
        assert isinstance(t[k], int)
        assert t[k] >= 0

    # shape fields always exist
    assert isinstance(body["blocks"], list)
    assert isinstance(body["figures"], list)
    assert "exports" in body

    # store_outputs=false => annotated must be null even if return_annotated=true
    assert body["exports"]["annotated_image_path"] is None

def test_annotated_file_created_when_requested(tmp_path, monkeypatch):
    # Force outputs into temp dir
    output_dir = Path(os.getenv("OUTPUT_DIR", "/shared_outputs"))
    img = _tiny_png_bytes()
    files = {"file": ("page.png", img, "image/png")}
    data = {
        "store_outputs": "true",
        "return_annotated": "true",
        "ocr_engine": "paddle"
    }

    r = httpx.post(f"{BASE_URL}/extract", files=files, data=data, timeout=120)
    assert r.status_code == 200

    body = r.json()
    annotated_path = body["exports"]["annotated_image_path"]

    assert annotated_path is not None
    assert annotated_path.startswith("/outputs/")
    assert annotated_path.endswith("annotated.png")

    # Map URL path to filesystem path
    parts = annotated_path.strip("/").split("/")   # ["outputs", "<request_id>", "annotated.png"]
    request_id = parts[1]
    fs_path = output_dir / request_id / "annotated.png"
    assert fs_path.exists()
    assert fs_path.is_file()


def test_input_image_saved_when_store_outputs_true():
    output_dir = Path(os.getenv("OUTPUT_DIR", "/shared_outputs"))

    img = _tiny_png_bytes()
    files = {"file": ("page.png", img, "image/png")}
    data = {
        "store_outputs": "true",
        "return_annotated": "false",
        "ocr_engine": "paddle"
    }

    r = httpx.post(f"{BASE_URL}/extract", files=files, data=data, timeout=120)
    assert r.status_code == 200

    body = r.json()
    request_id = body["meta"]["request_id"]

    input_image_path = output_dir / request_id / "input_page.png"

    assert input_image_path.exists()
    assert input_image_path.is_file()

def test_annotated_image_url_is_served():
    img = _tiny_png_bytes()
    files = {"file": ("page.png", img, "image/png")}
    data = {"store_outputs": "true", "return_annotated": "true", "ocr_engine": "paddle"}

    r = httpx.post(f"{BASE_URL}/extract", files=files, data=data, timeout=120)
    assert r.status_code == 200

    body = r.json()
    annotated_path = body["exports"]["annotated_image_path"]
    assert annotated_path is not None

    r2 = httpx.get(f"{BASE_URL}{annotated_path}", timeout=30)
    assert r2.status_code == 200
    assert r2.headers["content-type"].startswith("image/")
    assert len(r2.content) > 0
